#!/usr/bin/python

# TODO
# - Images are not reloaded.

import sys
import os
import optparse
import gtk
import gobject
import webkit
import json
import markdown
import pyinotify


toolbar_items = (
    (gtk.STOCK_GO_BACK, "Back", "back", None, 0),
    (gtk.STOCK_REFRESH, "Reload", "reload", None, 1),
    (gtk.STOCK_SAVE, "Save", "save", None, 2),
    (gtk.STOCK_CLOSE, "Close",  "stop", None, 3),
)

theme_items = (
    ('Github', 'github'),
    ('Bitbucket', 'bitbucket'),
    ('Solarized', 'solarized'),
    ('White on black', 'whiteonblack'),
)

class MBViewApp:
    def __init__(self, md_file, theme_dir, conf_file='~/.mdview.conf', theme='github',
                auto_reload=True, keep_on_top=False):
        self.md_file = os.path.realpath(md_file)
        self.theme_dir = theme_dir
        self.conf_file = conf_file
        self.theme = theme
        self.auto_reload = auto_reload
        self.keep_on_top = keep_on_top
        self.did_reload = False # Set to True on reload
        self.scroll_pos = None  # The scroll position before reload
        self.at_bottom = False  # If we were at the bottom before reload

        self.set_theme(theme)

        # Create default window state. Then override default window state with
        # configuration, if it exists.
        self.win_state = {
            'height': 700,
            'width': 668,
            'pos_x': 100,
            'pos_y': 100,
            'zoom_level': 1,
        }
        self.load_win_state()

        self.win_main = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win_main.resize(self.win_state['width'], self.win_state['height'])
        self.win_main.connect("destroy", self.ev_destroy)
        self.win_main.connect("configure-event", self.ev_resize)
        self.win_main.connect("key-press-event", self.ev_key_press)
        if self.keep_on_top:
            self.win_main.set_keep_above(True)

        self.webview = webkit.WebView()
        ws = self.webview.get_settings()
        ws.set_property('enable-plugins',False)
        self.webview.set_settings(ws)
        self.webview.set_zoom_level(self.win_state['zoom_level'])
        self.webview.set_maintains_back_forward_list(True)
        self.webview.connect('notify::load-status', self.ev_load_status)
        self.scroll_window = gtk.ScrolledWindow(None, None)
        self.scroll_window.add(self.webview)

        self.toolbar = gtk.Toolbar()
        self.toolbar.set_orientation(gtk.ORIENTATION_HORIZONTAL)
        self.toolbar.set_style(gtk.TOOLBAR_BOTH_HORIZ)
        #self.toolbar.set_style(gtk.TOOLBAR_BOTH)
        for toolbar_item in toolbar_items:
            stock_item, tooltip, callback, user_data, pos = toolbar_item
            callback_method = getattr(self, callback)
            button = gtk.ToolButton(stock_item)
            button.set_tooltip_text(tooltip)
            button.connect('clicked', callback_method)
            button.set_is_important(True)
            self.toolbar.insert(button, pos)

        menu = gtk.Menu()
        for theme_item in theme_items:
            menu_item = gtk.MenuItem(theme_item[0])
            menu_item.connect('activate', self.ev_tb_theme, theme_item[1])
            menu.append(menu_item)
            menu_item.show()
        toolbar_theme_menu = gtk.MenuToolButton(gtk.STOCK_PROPERTIES)
        toolbar_theme_menu.set_tooltip_text('Themes')
        toolbar_theme_menu.set_menu(menu)
        self.toolbar.insert(toolbar_theme_menu, 4)

        vbox = gtk.VBox()
        vbox.pack_start(self.toolbar, expand=False)
        vbox.pack_start(self.scroll_window, expand=True, fill=True)

        self.win_main.add(vbox)
        self.win_main.show_all()
        self.win_main.move(self.win_state['pos_x'], self.win_state['pos_y'])

        self.load_markdown(file(self.md_file, 'r').read())

        # Setup the inotify watcher
        if self.auto_reload:
            self.wm = pyinotify.WatchManager()
            mask = pyinotify.IN_MODIFY
            self.wm.add_watch(os.path.dirname(self.md_file), mask)
            self.notifier = pyinotify.Notifier(self.wm, self.auto_reload_handler, timeout=10)
            gobject.timeout_add(200, self.auto_reload_timer)

    def set_theme(self, theme):
        if os.path.isfile(theme):
            theme_path = theme
        else:
            theme_fname = theme + '.html'
            theme_path = os.path.join(self.theme_dir, theme_fname)
        if not os.path.isfile(theme_path):
            raise IOError("Not a valid theme file: '{}'".format(theme_path))
        self.theme_path = theme_path

    def ev_tb_theme(self, button, theme):
        self.set_theme(theme)
        self.reload()

    def auto_reload_handler(self, event):
        if event.pathname == self.md_file:
            self.reload()

    def auto_reload_timer(self):
        self.notifier.process_events()
        while self.notifier.check_events():  #loop in case more events appear while we are processing
            self.notifier.read_events()
            self.notifier.process_events()
        return True

    def load_win_state(self):
        try:
            with open(os.path.expanduser(self.conf_file), 'r') as f:
                self.win_state.update(json.load(f))
        except IOError as err:
            if err.errno == 2:
                pass
            else:
                raise

    def save_win_state(self):
        json.dump(self.win_state, file(os.path.expanduser('~/.mdview.conf'), 'w'))

    def back(self, toolbar_item=None):
        if self.webview.can_go_back():
            self.webview.go_back()
        else:
            # Since we loud the Markdown preview using load_html_string(),
            # there is no page to go back to, se we reload instead.
            self.reload()

    def reload(self, toolbar_item=None):
        self.did_reload = True
        self.load_markdown(file(self.md_file, 'r').read())

    def run(self):
        gtk.main()

    def stop(self, toolbar_item=None):
        self.save_win_state()
        gtk.main_quit()

    def load_markdown(self, md_text):
        # Save some scrolling state information so we can reset it after
        # reload.
        vadj = self.scroll_window.get_vadjustment()
        self.scroll_pos = vadj.value
        self.at_bottom = vadj.value == (vadj.upper - vadj.page_size)

        md_html = self.markdown_to_html(md_text)
        self.webview.load_html_string(md_html, 'file://' + self.md_file)

    def save(self, toolbar_item=None):
        file_chooser = gtk.FileChooserDialog(
            action=gtk.FILE_CHOOSER_ACTION_SAVE,
            buttons=(
                gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_SAVE, gtk.RESPONSE_OK
            ))
        response = file_chooser.run()
        if response == gtk.RESPONSE_OK:
            md_text = file(self.md_file, 'r').read()
            md_html = self.markdown_to_html(md_text)
            open(file_chooser.get_filename(), 'w').write(md_html)
        file_chooser.destroy()

    def markdown_to_html(self, md_text):
        theme_contents = open(self.theme_path, 'r').read()
        md_html = markdown.markdown(md_text)
        html = theme_contents.replace('{{{ contents }}}', md_html)
        return html

    def ev_key_press(self, widget, ev):
        """
        Handle keypress events.
        """
        if ev.keyval in (gtk.keysyms.Escape, gtk.keysyms.q):
            self.stop()
        elif ev.keyval in (gtk.keysyms.plus, gtk.keysyms.equal):
            self.webview.set_zoom_level(self.webview.get_zoom_level() + 0.2)
        elif ev.keyval == gtk.keysyms.minus:
            self.webview.set_zoom_level(self.webview.get_zoom_level() - 0.2)
        elif ev.keyval == gtk.keysyms.r:
            self.reload()
        elif ev.keyval == gtk.keysyms.j:
            # Scroll down
            vadj = self.scroll_window.get_vadjustment()
            if vadj.value < (vadj.upper - vadj.page_size):
                vadj.set_value(vadj.get_value() + 16)
        elif ev.keyval == gtk.keysyms.k:
            # Scroll up
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.get_value() - 16)
        elif ev.keyval == gtk.keysyms.G:
            # Scroll to bottom
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.upper - vadj.page_size)
        elif ev.keyval == gtk.keysyms.g:
            # Scroll to top
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(0)
        elif ev.keyval == gtk.keysyms.s:
            # Save document
            self.save()

    def ev_resize(self, window, ev_reposition):
        """
        Save window position and size on resize and move. We can then save it
        later when the application quits, even after the 'destroy' event has
        been triggered.
        """
        win_size = self.win_main.get_size()
        win_pos = self.win_main.get_position()
        zoom_level = self.webview.get_zoom_level()
        self.win_state = {
            'height': win_size[1],
            'width': win_size[0],
            'pos_x': win_pos[0],
            'pos_y': win_pos[1],
            'zoom_level': zoom_level,
        }

    def ev_load_status(self, webview, load_status):
        """
        Handle events regarding load status:

        - Set back the scroll position after a reload.
        """
        if (
            self.did_reload and
            self.webview.get_load_status() == webkit.LOAD_FINISHED
           ):
            while gtk.events_pending():
                gtk.main_iteration_do()
            vadj = self.scroll_window.get_vadjustment()
            if not self.at_bottom:
                # Scroll back to previous position
                vadj.set_value(self.scroll_pos)
            else:
                # Previously at bottom, so scroll to bottom, to show any new
                # content
                vadj.set_value(vadj.upper - vadj.page_size)
            self.did_reload = False

    def ev_destroy(self, widget):
        """
        Window was destroyed. Call stop routine to save state and such.
        """
        self.stop()


if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.set_usage(sys.argv[0] + " <file.md>")

    parser.add_option("-k", "--keep-on-top", dest="keep_on_top", action="store_true", default=False, help="Keep window on top")
    parser.add_option("-t", "--theme", dest="theme", action="store", default='github', help="Theme (name or full path to .html). Default: github")

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.print_usage()
        sys.exit(1)

    try:
        with open(args[0], 'r') as test_open:
            pass
    except IOError as err:
        sys.stderr.write("{}\n".format(err))
        sys.exit(1)

    theme_dir = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'themes')
    mbviewapp = MBViewApp(args[0], theme_dir=theme_dir, theme=options.theme,
                          keep_on_top=options.keep_on_top)
    mbviewapp.run()
