#!/usr/bin/env python3

import sys
if sys.version_info.major < 3:
    sys.stderr.write("This script requires python3\n")
    sys.exit(1)
import os
import logging
import optparse
import webbrowser
import signal
import markdown
import pyinotify
from PyQt5.Qt import *

app_name = "mdpreview"
app_version = "2.0"

# Setup logging
level = logging.WARNING
log = logging.getLogger(app_name)
log.setLevel(level)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s %(levelname)8s %(name)s | %(message)s')
ch.setFormatter(formatter)
log.addHandler(ch)

theme_items = (
    ('Bitbucket', 'bitbucket'),
    ('Dark', 'dark'),
    ('Github', 'github'),
    ('Solarized', 'solarized'),
    ('White on black', 'whiteonblack'),
)

toolbar_items = [
    {
        "id": "tb-back",
        "type": "button",
        "event": "back",
        "icon": "go-previous",
        "label": "Go back to the previous page",
        "shortcut": "B",
    },
    {
        "id": "tb-close",
        "type": "button",
        "event": "close",
        "icon": "application-exit",
        "label": "Exit mdpreview",
        "shortcut": "Escape",
    },
    {
        "id": "tb-keepontop",
        "type": "check",
        "event": "toggle_keepontop",
        "icon": "go-top",
        "label": "Keep window on top",
        "shortcut": "T",
    },
    {
        "id": "tb-savehtml",
        "type": "button",
        "event": "savehtml",
        "icon": "document-save-as",
        "label": "Save as HTML",
        "shortcut": "S",
    },
    {
        "id": "tb-theme",
        # The theme dropdown is constructed in code from theme_items. See
        # GUI._make_toolbar
    }
]

keypress_items = [
    {
        "key": Qt.Key_J,
        "event": "scroll_down",
    },
    {
        "key": Qt.Key_K,
        "event": "scroll_up",
    },
    {
        "key": Qt.Key_Q,
        "event": "close",
    },
    {
        "key": Qt.Key_R,
        "event": "reload"
    }
]


class MDRenderer:
    """
    Render Markdown to HTML according to a theme.
    """
    def __init__(self, theme_dir, default_theme="github"):
        self.theme_dir = theme_dir
        self.default_theme = default_theme

    def get_theme_path(self, theme):
        """
        Return the full path to the theme `theme`. This is either a relative or
        absolute path if `theme` points to an existing file, or the path to oen
        of the built-in themes.
        """
        if os.path.isfile(theme):
            # Theme points to an existing file
            theme_path = theme
        else:
            theme_fname = theme + '.html'
            theme_path = os.path.join(self.theme_dir, theme_fname)
        if not os.path.isfile(theme_path):
            raise IOError("Not a valid theme file: '{}'".format(theme_path))
        return theme_path

    def render(self, path, theme=None):
        """
        Render the contents of `path` according to the currently set theme.
        """
        theme_contents = self._read_theme(theme)
        md_contents = open(path, 'r').read()
        md_html = markdown.markdown(md_contents)
        html = theme_contents.replace('{{{ contents }}}', md_html)
        return html

    def _read_theme(self, theme):
        """
        Load theme from disk.
        """
        if theme is None:
            theme = self.default_theme
        theme_path = self.get_theme_path(theme)
        theme_contents = open(theme_path, 'r').read()
        return theme_contents


class GUI:
    """
    Main GUI class.
    """
    def __init__(self, md_renderer, keep_on_top=False):
        self.md_renderer = md_renderer
        self.keep_on_top = keep_on_top
        self.cur_path = None  # Set by load_md()
        self.cur_scroll_pos = None
        self.history = []

        icon_path = \
            os.path.join(
                os.path.dirname(
                    os.path.realpath(sys.argv[0])
                ),
                "mdpreview_icon.png"
            )
        self.win = QMainWindow()
        self.win.setWindowIcon(QIcon(icon_path))
        self.win.closeEvent = self._ev_close_event
        if self.keep_on_top is True:
            self.win.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.win.keyPressEvent = self._ev_key_press

        self._make_toolbar()
        self._make_webview()
        self._make_watchmanager()

        self.win.show()
        self.webview.setFocus()

    def _make_toolbar(self):
        """
        Generate the toolbar.
        """
        self.toolbar = self.win.addToolBar('toolbar')

        # Addd items from toolbar_items to the toolbar
        for toolbar_item in toolbar_items:
            if toolbar_item["id"] != "tb-theme":
                action = QAction(QIcon.fromTheme(toolbar_item["icon"]),
                                 toolbar_item["label"],
                                 self.win)
                action.setData(toolbar_item["id"])
                if toolbar_item["type"] == "check":
                    action.setCheckable(True)
                if toolbar_item["id"] == "tb-keepontop" and self.keep_on_top is True:
                    action.setChecked(True)
                if toolbar_item["shortcut"] is not None:
                    action.setShortcut(toolbar_item["shortcut"])
                event_cb = getattr(self, "_ev_{}".format(toolbar_item["event"]))
                action.triggered.connect(event_cb)
                self.toolbar.addAction(action)
            else:
                # Add the theme dropdown selector
                self.toolbar.addSeparator()
                self.toolbar.addWidget(QLabel("Theme "))
                self.theme_dropdown = QComboBox(self.win)
                current_index = None
                current_theme = self.md_renderer.default_theme
                for theme_index, theme_item in enumerate(theme_items):
                    self.theme_dropdown.addItem(theme_item[0], theme_item[1])
                    if theme_item[1] == current_theme:
                        current_index = theme_index
                if current_index is not None:
                    self.theme_dropdown.setCurrentIndex(current_index)
                self.theme_dropdown.currentIndexChanged.connect(self._ev_theme_dropdown_changed)
                self.toolbar.addWidget(self.theme_dropdown)

    def _make_webview(self):
        """
        Generate the central layout with the web view.
        """
        self.layout = QVBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0);
        self.central = QWidget();
        self.central.setLayout(self.layout)
        self.win.setCentralWidget(self.central)
        self.webview = QWebView()
        self.layout.addWidget(self.webview)
        self.webview.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks)
        self.webview.linkClicked.connect(self._ev_webview_link_clicked)
        self.webview.loadFinished.connect(self._ev_webview_load_finished)

    def _make_watchmanager(self):
        """
        Set up the inotify watch manager, that can watch for changes in files.
        Watches are added when loading a markdown file through self.load_md().
        """
        self.watchmanager = pyinotify.WatchManager()
        self.notifier = pyinotify.Notifier(self.watchmanager,
                                           self._watch_notifier,
                                           timeout=10)
        self.win.timerEvent = self._timerEvent
        self.win.startTimer(200)

    def _timerEvent(self, event):
        """
        Check for inotify events. Called by self.win.timerEvent.
        """
        self.notifier.process_events()
        while self.notifier.check_events():  #loop in case more events appear while we are processing
            log.debug("_timerEvent: inotify events pending")
            self.notifier.read_events()
            self.notifier.process_events()

    def _get_toolbar_action(self, id):
        """
        Helper method to get the Action that belongs to toolbar_item[id] from
        the toolbar.
        """
        for action in self.toolbar.actions():
            if action.data() == id:
                return action

    def load_md(self, path, theme=None):
        """
        Render `path` as Markdown to HTML according to `theme` and display it
        in the web view. Also sets up the inotify events to watch for changes
        to `path`, sets the window title, etc.
        """
        log.info("Loading '{}' with theme '{}'".format(path, theme))

        # Clear web view cache
        QWebSettings.clearMemoryCaches();

        # Render MD to HTML and display
        rel_path = os.path.dirname(os.path.realpath(path))
        rel_url = "file://{}/".format(rel_path)
        self.webview.setHtml(self.md_renderer.render(path, theme), QUrl(rel_url))

        # Remove previous file modification watchers
        log.info("Removing current inotify watches")
        self.watchmanager.rm_watch(list(self.watchmanager.watches.keys()))

        # Watch the file for modifications
        log.info("Adding {} to the inotify watch list".format(path))
        mask = pyinotify.IN_MODIFY
        self.watchmanager.add_watch(os.path.dirname(path), mask)

        # Set window title
        self.win.setWindowTitle("{}: {}".format(app_name, path))

        # Track some metadata
        self.cur_path = path
        self.cur_theme = theme

        # Gray out the 'Back' button
        action = self._get_toolbar_action('tb-back')
        if len(self.history) == 0:
            action.setEnabled(False)
        else:
            action.setEnabled(True)

    def reload(self):
        """
        Reload the currently viewed Markdown file (self.cur_path). Stores the
        current scroll position so that when the webview `loadFinished` event
        triggers, the page is scrolled back to the previous position.
        """
        frame = self.webview.page().mainFrame()
        scroll_pos = frame.scrollPosition()

        if scroll_pos.y() == frame.scrollBarMaximum(Qt.Vertical):
            self.cur_scroll_pos = [scroll_pos.x(), -1]  # At bottom
        else:
            self.cur_scroll_pos = self._get_webview_scrollpos()

        log.info("Reloading '{}'. theme={}, scroll_pos={}".format(self.cur_path, self.cur_theme, self.cur_scroll_pos))
        self.load_md(self.cur_path, self.cur_theme)

    def _get_webview_scrollpos(self):
        """
        Return the current scroll position x and y coordinates of the webview.
        """
        frame = self.webview.page().mainFrame()
        scroll_pos = frame.scrollPosition()
        return  (scroll_pos.x(), scroll_pos.y())

    def _watch_notifier(self, event):
        """
        Called when changes are detected by inotify to the file we're currently
        watching. This is set up by `self.load_md()`.
        """
        log.info("inotify event: {}".format(event))
        self.reload()

    def _ev_key_press(self, keypress):
        """
        Handle key press events. Looks in `keypress_items` for actions.
        """
        for keypress_item in keypress_items:
            if keypress.key() == keypress_item["key"]:
                event_cb = getattr(self, "_ev_{}".format(keypress_item["event"]))
                event_cb()

    def _ev_back(self):
        """
        Toolbar: Go back in history.
        """
        if len(self.history) > 0:
            log.info("history: {}".format(self.history))
            path = self.history.pop()
            log.info("Popped '{}' from the history".format(path))
            self.load_md(path, self.cur_theme)

    def _ev_close_event(self, event):
        """
        Catch the user pressing the [X] button and cleanly close the app.
        """
        self._ev_close()

    def _ev_close(self):
        """
        Toolbar: Quit application
        """
        log.info("Quiting application")
        QCoreApplication.quit()

    def _ev_toggle_keepontop(self):
        """
        Toolbar: Toogle the Keep-on-top function
        """
        action = self._get_toolbar_action('tb-keepontop')
        if self.keep_on_top is True:
            self.keep_on_top = False
            action.setChecked(False)
            self.win.setWindowFlag(Qt.WindowStaysOnTopHint, False)
            self.win.show()
        else:
            self.keep_on_top = True
            action.setChecked(True)
            self.win.setWindowFlag(Qt.WindowStaysOnTopHint, True)
            self.win.show()

    def _ev_savehtml(self):
        """
        Toolbar: Save current Markdown file as HTML.
        """
        file_info = QFileDialog.getSaveFileName(self.win, "Save as HTML...")
        if file_info[0] != '':
            with open(file_info[0], 'w') as f:
                f.write(self.md_renderer.render(self.cur_path, self.cur_theme))

    def _ev_theme_dropdown_changed(self, new_index):
        """
        Toolbar: Change the theme and reload current file.
        """
        theme = theme_items[new_index]
        self.cur_theme = theme[1]
        self.reload()

    def _ev_webview_link_clicked(self, url):
        """
        Called when the user clicks a link in the current file. If it's a local
        link, open it in mdpreview. Otherwise open it in the user's browser.
        """
        # FIXME: Should look at extension (.md).
        # FIXME: Should be able to load https://example.com/README.md in mdpreview
        if url.scheme() == "" or url.scheme() == "file":
            log.info("Adding '{}' to the history".format(self.cur_path))
            self.history.append(self.cur_path)
            self.load_md(url.path())
        else:
            webbrowser.open_new_tab(url.url())

    def _ev_webview_load_finished(self, ok):
        """
        Called when the current file is done loading in the web view. Scrolls
        back to the previous position in the file we're viewing, if set. We
        need to do this in an event, otherwise the part of the document we're
        trying to scroll too may not have been loaded yet.
        """
        frame = self.webview.page().mainFrame()
        if self.cur_scroll_pos is not None:
            if self.cur_scroll_pos[1] == -1:
                x = self.cur_scroll_pos[0]
                y = frame.scrollBarMaximum(Qt.Vertical)
                log.info("Scrolling to bottom")
            else:
                x = self.cur_scroll_pos[0]
                y = self.cur_scroll_pos[1]
                log.info("Scrolling back to {}, {}".format(x, y))
            frame.setScrollPosition(QPoint(x, y))

            # Reset scroll pos, in case we load a file outside of the reload
            # mechanism (e.g. clicking a link)
            self.cur_scroll_pos = None

    def _ev_scroll_down(self):
        """
        Scroll the webview down.
        """
        frame = self.webview.page().mainFrame()
        frame.scroll(0, 60)

    def _ev_scroll_up(self):
        """
        Scroll the webview up.
        """
        frame = self.webview.page().mainFrame()
        frame.scroll(0, -60)

    def _ev_reload(self):
        self.reload()


if __name__ == "__main__":
    parser = optparse.OptionParser(version="%prog v{}".format(app_version))
    parser.set_usage(sys.argv[0] + " <file.md>")

    parser.add_option("-d",
                      "--debug",
                      dest="debug",
                      action="store_true",
                      default=False,
                      help="Show debugging info")
    parser.add_option("-k",
                      "--keep-on-top",
                      dest="keep_on_top",
                      action="store_true",
                      default=False,
                      help="Keep window on top")
    parser.add_option("-t",
                      "--theme",
                      dest="theme",
                      action="store",
                      default="github",
                      help="Theme (name or full path to .html). Default: github")

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.print_usage()
        sys.exit(1)

    # Enable debugging
    if options.debug:
        log.setLevel(logging.DEBUG)

    # Try to open the specified markdown file before doing anything else, so we
    # don't flash a useless window on the screen.
    try:
        with open(args[0], 'r') as test_open:
            pass
    except IOError as err:
        sys.stderr.write("{}\n".format(err))
        sys.exit(1)

    # Make sure ctrl-c on the commandline stops the application
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    theme_dir = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'themes')
    md_renderer = MDRenderer(theme_dir=theme_dir, default_theme=options.theme)
    app = QApplication(args)
    gui = GUI(md_renderer, options.keep_on_top)
    gui.load_md(args[0])
    app.exec_()
