#!/usr/bin/python

# TODO
# - If scrolled to bottom and new stuff is appended, scroll down automatically dkfljd.
import sys
import os
import optparse
import gtk
import gobject
import webkit
import json
import markdown
import pyinotify


class MBViewApp:
    def __init__(self, md_file, conf_file='~/.mdview.conf', theme='github', auto_reload=True):
        self.md_file = os.path.realpath(md_file)
        self.conf_file = conf_file
        self.theme = theme
        self.auto_reload = auto_reload
        self.scroll_pos = None

        # Get full path to theme
        if theme.startswith('/'):
            self.theme_path = theme
        else:
            tpl_fname = self.theme + '.html'
            tpl_dir = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'themes')
            tpl_path = os.path.join(tpl_dir, tpl_fname)
            self.theme_path = tpl_path
        if not os.path.isfile(self.theme_path):
            raise IOError("Not a valid theme file: '{}'".format(self.theme_path))

        # Create default window state. Then override default window state with
        # configuration, if it exists.
        self.win_state = {
            'height': 700,
            'width': 900,
            'pos_x': 100,
            'pos_y': 100,
            'zoom_level': 1,
        }
        self.load_win_state()

        self.win_main = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win_main.resize(self.win_state['width'], self.win_state['height'])
        self.win_main.connect("destroy", self.ev_destroy)
        self.win_main.connect("configure-event", self.ev_resize)
        self.win_main.connect("key-press-event", self.ev_key_press)

        self.webview = webkit.WebView()
        ws = self.webview.get_settings()
        ws.set_property('enable-plugins',False)
        self.webview.set_settings(ws)
        self.webview.set_zoom_level(self.win_state['zoom_level'])
        self.webview.connect('notify::load-status', self.ev_load_status)

        self.scroll_window = gtk.ScrolledWindow(None, None)
        self.scroll_window.add(self.webview)

        self.win_main.add(self.scroll_window)
        self.win_main.show_all()
        self.win_main.move(self.win_state['pos_x'], self.win_state['pos_y'])

        self.load_markdown(file(self.md_file, 'r').read())

        # Setup the inotify watcher
        if self.auto_reload:
            self.wm = pyinotify.WatchManager()
            mask = pyinotify.IN_MODIFY
            self.wm.add_watch(os.path.dirname(self.md_file), mask, rec=True) # FIXME: PATH
            self.notifier = pyinotify.Notifier(self.wm, self.auto_reload_handler, timeout=10)
            gobject.timeout_add(200, self.auto_reload_timer)

    def auto_reload_handler(self, event):
        if event.pathname == self.md_file:
            self.load_markdown(file(self.md_file, 'r').read())

    def auto_reload_timer(self):
        self.notifier.process_events()
        while self.notifier.check_events():  #loop in case more events appear while we are processing
            self.notifier.read_events()
            self.notifier.process_events()
        return True

    def load_win_state(self):
        try:
            with open(os.path.expanduser(self.conf_file), 'r') as f:
                self.win_state.update(json.load(f))
        except IOError as err:
            if err.errno == 2:
                pass
            else:
                raise

    def save_win_state(self):
        json.dump(self.win_state, file(os.path.expanduser('~/.mdview.conf'), 'w'))

    def reload(self):
        self.load_markdown(file(self.md_file, 'r').read())

    def run(self):
        gtk.main()

    def stop(self):
        self.save_win_state()
        gtk.main_quit()

    def load_markdown(self, md_text):
        self.scroll_pos = self.scroll_window.get_vadjustment().get_value()
        theme_contents = open(self.theme_path, 'r').read()
        md_html = markdown.markdown(md_text)
        html = theme_contents.replace('{{{ contents }}}', md_html)
        self.webview.load_html_string(html, 'file:///')

    def ev_key_press(self, widget, ev):
        """
        Handle keypress events.
        """
        if ev.keyval in (gtk.keysyms.Escape, gtk.keysyms.q):
            self.stop()
        elif ev.keyval in (gtk.keysyms.plus, gtk.keysyms.equal):
            self.webview.set_zoom_level(self.webview.get_zoom_level() + 0.2)
        elif ev.keyval == gtk.keysyms.minus:
            self.webview.set_zoom_level(self.webview.get_zoom_level() - 0.2)
        elif ev.keyval == gtk.keysyms.r:
            self.reload()
        elif ev.keyval == gtk.keysyms.j:
            # Scroll down
            vadj = self.scroll_window.get_vadjustment()
            if vadj.value < (vadj.upper - vadj.page_size):
                vadj.set_value(vadj.get_value() + 16)
        elif ev.keyval == gtk.keysyms.k:
            # Scroll up
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.get_value() - 16)
        elif ev.keyval == gtk.keysyms.G:
            # Scroll to bottom
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.upper - vadj.page_size)
        elif ev.keyval == gtk.keysyms.g:
            # Scroll to top
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(0)

    def ev_resize(self, window, ev_reposition):
        """
        Save window position and size on resize and move. We can then save it
        later when the application quits, even after the 'destroy' event has
        been triggered.
        """
        win_size = self.win_main.get_size()
        win_pos = self.win_main.get_position()
        zoom_level = self.webview.get_zoom_level()
        self.win_state = {
            'height': win_size[1],
            'width': win_size[0],
            'pos_x': win_pos[0],
            'pos_y': win_pos[1],
            'zoom_level': zoom_level,
        }

    def ev_load_status(self, webview, load_status):
        """
        Handle events regarding load status:

        - Set back the scroll position after a reload.
        """
        if (
            self.scroll_pos is not None and
            self.webview.get_load_status() == webkit.LOAD_FINISHED
           ):
            while gtk.events_pending():
                gtk.main_iteration_do()
            self.scroll_window.get_vadjustment().set_value(self.scroll_pos)
            self.scroll_pos = None

    def ev_destroy(self, widget):
        """
        Window was destroyed. Call stop routine to save state and such.
        """
        self.stop()


if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.set_usage(sys.argv[0] + " <file.md>")

    #parser.add_option("-V", "--verbose", dest="verbose", action="store_true", default=False, help="Be verbose (show lots of output)")
    #parser.add_option("-l", "--log-stdout", dest="log_stdout", action="store_true", default=False, help="Also log to stdout")
    parser.add_option("-t", "--theme", dest="theme", action="store", default='github', help="Theme (name or full path to .html). Default: github")
    #parser.add_option("-f", "--foreground", dest="foreground", action="store_true", default=False, help="Do not go into daemon mode.")

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.print_usage()
        sys.exit(1)

    mbviewapp = MBViewApp(args[0], theme=options.theme)
    mbviewapp.run()
