#!/usr/bin/python

# TODO
# - Images are not reloaded.
# - Support back-nagivation after clicking a link.

import sys
import os
import optparse
import gtk
import gobject
import webkit
import json
import markdown
import pyinotify


class MBViewApp:
    def __init__(self, md_file, conf_file='~/.mdview.conf', theme='github',
                auto_reload=True, keep_on_top=False):
        self.md_file = os.path.realpath(md_file)
        self.conf_file = conf_file
        self.theme = theme
        self.auto_reload = auto_reload
        self.keep_on_top = keep_on_top
        self.did_reload = False # Set to True on reload
        self.scroll_pos = None  # The scroll position before reload
        self.at_bottom = False  # If we were at the bottom before reload

        # Get full path to theme
        if theme.startswith('/'):
            self.theme_path = theme
        else:
            tpl_fname = self.theme + '.html'
            tpl_dir = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'themes')
            tpl_path = os.path.join(tpl_dir, tpl_fname)
            self.theme_path = tpl_path
        if not os.path.isfile(self.theme_path):
            raise IOError("Not a valid theme file: '{}'".format(self.theme_path))

        # Create default window state. Then override default window state with
        # configuration, if it exists.
        self.win_state = {
            'height': 700,
            'width': 668,
            'pos_x': 100,
            'pos_y': 100,
            'zoom_level': 1,
        }
        self.load_win_state()

        self.win_main = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win_main.resize(self.win_state['width'], self.win_state['height'])
        self.win_main.connect("destroy", self.ev_destroy)
        self.win_main.connect("configure-event", self.ev_resize)
        self.win_main.connect("key-press-event", self.ev_key_press)
        if self.keep_on_top:
            self.win_main.set_keep_above(True)

        self.webview = webkit.WebView()
        ws = self.webview.get_settings()
        ws.set_property('enable-plugins',False)
        self.webview.set_settings(ws)
        self.webview.set_zoom_level(self.win_state['zoom_level'])
        self.webview.connect('notify::load-status', self.ev_load_status)

        self.scroll_window = gtk.ScrolledWindow(None, None)
        self.scroll_window.add(self.webview)

        self.win_main.add(self.scroll_window)
        self.win_main.show_all()
        self.win_main.move(self.win_state['pos_x'], self.win_state['pos_y'])

        self.load_markdown(file(self.md_file, 'r').read())

        # Setup the inotify watcher
        if self.auto_reload:
            self.wm = pyinotify.WatchManager()
            mask = pyinotify.IN_MODIFY
            self.wm.add_watch(os.path.dirname(self.md_file), mask, rec=True) # FIXME: PATH
            self.notifier = pyinotify.Notifier(self.wm, self.auto_reload_handler, timeout=10)
            gobject.timeout_add(200, self.auto_reload_timer)

    def auto_reload_handler(self, event):
        if event.pathname == self.md_file:
            self.reload()

    def auto_reload_timer(self):
        self.notifier.process_events()
        while self.notifier.check_events():  #loop in case more events appear while we are processing
            self.notifier.read_events()
            self.notifier.process_events()
        return True

    def load_win_state(self):
        try:
            with open(os.path.expanduser(self.conf_file), 'r') as f:
                self.win_state.update(json.load(f))
        except IOError as err:
            if err.errno == 2:
                pass
            else:
                raise

    def save_win_state(self):
        json.dump(self.win_state, file(os.path.expanduser('~/.mdview.conf'), 'w'))

    def reload(self):
        self.did_reload = True
        self.load_markdown(file(self.md_file, 'r').read())

    def run(self):
        gtk.main()

    def stop(self):
        self.save_win_state()
        gtk.main_quit()

    def load_markdown(self, md_text):
        # Save some scrolling state information so we can reset it after
        # reload.
        vadj = self.scroll_window.get_vadjustment()
        self.scroll_pos = vadj.value
        self.at_bottom = vadj.value == (vadj.upper - vadj.page_size)

        md_html = self.markdown_to_html(md_text)
        self.webview.load_html_string(md_html, 'file://' + self.md_file)

    def save(self):
        file_chooser = gtk.FileChooserDialog(
            action=gtk.FILE_CHOOSER_ACTION_SAVE,
            buttons=(
                gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_SAVE, gtk.RESPONSE_OK
            ))
        response = file_chooser.run()
        if response == gtk.RESPONSE_OK:
            md_text = file(self.md_file, 'r').read()
            md_html = self.markdown_to_html(md_text)
            open(file_chooser.get_filename(), 'w').write(md_html)
        file_chooser.destroy()

    def markdown_to_html(self, md_text):
        theme_contents = open(self.theme_path, 'r').read()
        md_html = markdown.markdown(md_text)
        html = theme_contents.replace('{{{ contents }}}', md_html)
        return html

    def ev_key_press(self, widget, ev):
        """
        Handle keypress events.
        """
        if ev.keyval in (gtk.keysyms.Escape, gtk.keysyms.q):
            self.stop()
        elif ev.keyval in (gtk.keysyms.plus, gtk.keysyms.equal):
            self.webview.set_zoom_level(self.webview.get_zoom_level() + 0.2)
        elif ev.keyval == gtk.keysyms.minus:
            self.webview.set_zoom_level(self.webview.get_zoom_level() - 0.2)
        elif ev.keyval == gtk.keysyms.r:
            self.reload()
        elif ev.keyval == gtk.keysyms.j:
            # Scroll down
            vadj = self.scroll_window.get_vadjustment()
            if vadj.value < (vadj.upper - vadj.page_size):
                vadj.set_value(vadj.get_value() + 16)
        elif ev.keyval == gtk.keysyms.k:
            # Scroll up
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.get_value() - 16)
        elif ev.keyval == gtk.keysyms.G:
            # Scroll to bottom
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.upper - vadj.page_size)
        elif ev.keyval == gtk.keysyms.g:
            # Scroll to top
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(0)
        elif ev.keyval == gtk.keysyms.s:
            # Save document
            self.save()

    def ev_resize(self, window, ev_reposition):
        """
        Save window position and size on resize and move. We can then save it
        later when the application quits, even after the 'destroy' event has
        been triggered.
        """
        win_size = self.win_main.get_size()
        win_pos = self.win_main.get_position()
        zoom_level = self.webview.get_zoom_level()
        self.win_state = {
            'height': win_size[1],
            'width': win_size[0],
            'pos_x': win_pos[0],
            'pos_y': win_pos[1],
            'zoom_level': zoom_level,
        }

    def ev_load_status(self, webview, load_status):
        """
        Handle events regarding load status:

        - Set back the scroll position after a reload.
        """
        if (
            self.did_reload and
            self.webview.get_load_status() == webkit.LOAD_FINISHED
           ):
            while gtk.events_pending():
                gtk.main_iteration_do()
            vadj = self.scroll_window.get_vadjustment()
            if not self.at_bottom:
                # Scroll back to previous position
                vadj.set_value(self.scroll_pos)
            else:
                # Previously at bottom, so scroll to bottom, to show any new
                # content
                vadj.set_value(vadj.upper - vadj.page_size)
            self.did_reload = False

    def ev_destroy(self, widget):
        """
        Window was destroyed. Call stop routine to save state and such.
        """
        self.stop()


if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.set_usage(sys.argv[0] + " <file.md>")

    #parser.add_option("-V", "--verbose", dest="verbose", action="store_true", default=False, help="Be verbose (show lots of output)")
    #parser.add_option("-l", "--log-stdout", dest="log_stdout", action="store_true", default=False, help="Also log to stdout")
    parser.add_option("-k", "--keep-on-top", dest="keep_on_top", action="store_true", default=False, help="Keep window on top")
    parser.add_option("-t", "--theme", dest="theme", action="store", default='github', help="Theme (name or full path to .html). Default: github")
    #parser.add_option("-f", "--foreground", dest="foreground", action="store_true", default=False, help="Do not go into daemon mode.")

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.print_usage()
        sys.exit(1)

    mbviewapp = MBViewApp(args[0], theme=options.theme, keep_on_top=options.keep_on_top)
    mbviewapp.run()
