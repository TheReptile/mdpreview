#!/usr/bin/python

# TODO
# - Images are not reloaded.

import sys
import os
import optparse
import gtk
import gobject
import webkit
import json
import markdown
import pyinotify


# Toolbar items:
#    (stock_id, label/tooltip, callback_name, private_label, position)
#  callback_name will be mapped to GUI.ev_tb_XXX methods
toolbar_items = (
    (gtk.STOCK_GO_BACK, "Back", "back", None, 0),
    (gtk.STOCK_REFRESH, "Reload", "reload", None, 1),
    (gtk.STOCK_SAVE, "Save HTML", "save_html", None, 2),
    (gtk.STOCK_CLOSE, "Close",  "stop", None, 3),
)

theme_items = (
    ('Github', 'github'),
    ('Bitbucket', 'bitbucket'),
    ('Solarized', 'solarized'),
    ('White on black', 'whiteonblack'),
)

class Config:
    def __init__(self, conf_file):
        self.conf_file = conf_file
        self.default_config = {
            'height': 700,
            'width': 668,
            'pos_x': 100,
            'pos_y': 100,
            'zoom_level': 1,
            'theme': 'github',
        }
        self.config = self.default_config.copy()
        self.load()

    def load(self):
        try:
            with open(self.conf_file, 'r') as f:
                self.config.update(json.load(f))
        except IOError as err:
            if err.errno == 2:
                pass
            else:
                raise

    def save(self):
        with open(self.conf_file, 'w') as f:
            json.dump(self.config, f)

    def get(self, key):
        return self.config[key]

    def set(self, key, value):
        self.config[key] = value

class MDRenderer:
    """
    Render Markdown to HTML according to a theme. Also watches the given
    markdown file for changes if `auto_reload` is True.
    """
    def __init__(self, md_file, theme_dir, theme="github", auto_reload=True):
        self.theme_dir = theme_dir
        self.theme = theme
        self.auto_reload = auto_reload
        self.watch_notify_callbacks = []

        # Set theme properties
        self.set_theme(theme)  # Sets self.theme_path

        # Set mardown file
        md_path = os.path.realpath(md_file)
        with open(md_path, 'r') as md_fh:  # Trigger IOErrors
            pass
        self.md_file = md_file
        self.md_path = md_path

        if self.auto_reload:
            self.watchmanager = pyinotify.WatchManager()
            mask = pyinotify.IN_MODIFY
            self.watchmanager.add_watch(os.path.dirname(self.md_path), mask)
            self.notifier = pyinotify.Notifier(self.watchmanager,
                                               self._watch_notifier,
                                               timeout=10)

    def set_theme(self, theme):
        """
        Set the theme to use. `theme` is either a path to an existing file, or
        the name of a theme. If `theme` is not a path to an existing file, the
        theme will be looked up in `self.theme_dir`.
        """
        if os.path.isfile(theme):
            theme_path = theme
        else:
            theme_fname = theme + '.html'
            theme_path = os.path.join(self.theme_dir, theme_fname)
        if not os.path.isfile(theme_path):
            raise IOError("Not a valid theme file: '{}'".format(theme_path))
        self.theme = theme
        self.theme_path = theme_path

    def get_theme_path(self):
        """
        Return the full path to the current theme being used.
        """
        return self.theme_path

    def get_md_path(self):
        """
        Return the full path to the current markdown file being used.
        """
        return self.md_path

    def render(self):
        """
        Render the contents of `self.md_file` according to `self.theme_path`.
        """
        theme_contents = open(self.theme_path, 'r').read()
        md_contents = open(self.md_file, 'r').read()
        md_html = markdown.markdown(md_contents)
        html = theme_contents.replace('{{{ contents }}}', md_html)
        return html

    def add_watch_notify_callback(self, cb):
        """
        Add a callback to be called when the contents of `self.md_path` changes
        (if `self.auto_reload` is True).
        """
        self.watch_notify_callbacks.append(cb)

    def watch_update(self):
        """
        Method to synchroniously update inotify events.
        """
        if self.auto_reload:
            self.notifier.process_events()
            while self.notifier.check_events():  #loop in case more events appear while we are processing
                self.notifier.read_events()
                self.notifier.process_events()

    def _watch_notifier(self, event):
        """
        inotify callback handler
        """
        if event.pathname == self.md_path:
            for watch_notify_callback in self.watch_notify_callbacks:
                watch_notify_callback()


class GUI:
    """
    mdpreview GUI.
    """
    def __init__(self, mdrenderer, width=668, height=700, pos_x=100, pos_y=100,
                 zoom_level=1, auto_reload=True, keep_on_top=False):
        self.mdrenderer = mdrenderer
        self.width = width
        self.height = height
        self.pos_x = pos_x
        self.pos_y = pos_y
        self.zoom_level = zoom_level
        self.auto_reload = auto_reload
        self.keep_on_top = keep_on_top

        self.did_reload = False  # Set to True on reload
        self.scroll_pos = None   # The scroll position before reload
        self.at_bottom = False   # If we were at the bottom before reload

        # Construct widgets
        self.win_main = self.make_win_main(self.width,
                                           self.height,
                                           self.keep_on_top,
                                           self.pos_x,
                                           self.pos_y)
        self.toolbar = self.make_toolbar(toolbar_items, theme_items)
        self.webview = self.make_webview(self.zoom_level)
        self.scroll_window = gtk.ScrolledWindow(None, None)
        self.scroll_window.add(self.webview)

        # Connect events
        self.win_main.connect("destroy", self.ev_destroy)
        self.win_main.connect("configure-event", self.ev_configure_event)
        self.win_main.connect("key-press-event", self.ev_key_press)
        self.webview.connect('notify::load-status', self.ev_load_status)

        # Pick it, pack it, fire it up, come along...
        vbox = gtk.VBox()
        vbox.pack_start(self.toolbar, expand=False)
        vbox.pack_start(self.scroll_window, expand=True, fill=True)

        self.win_main.add(vbox)
        self.win_main.show_all()

        self.load_markdown()

        # Periodically trigger inotify events so we detect changes in the
        # loaded content
        self.mdrenderer.add_watch_notify_callback(self.do_reload)
        gobject.timeout_add(200, self.auto_reload_timer)

    def make_win_main(self, width, height, keep_on_top, pos_x, pos_y):
        win_main = gtk.Window(gtk.WINDOW_TOPLEVEL)
        icon_path = os.path.join(
            os.path.dirname(os.path.realpath(sys.argv[0])),
            'mdpreview_icon.png'
        )
        win_main.set_icon_from_file(icon_path)
        win_main.resize(width, height)
        win_main.set_keep_above(keep_on_top)
        win_main.move(pos_x, pos_y)
        return win_main

    def make_webview(self, zoom_level):
        webview = webkit.WebView()
        ws = webview.get_settings()
        ws.set_property('enable-plugins', False)
        ws.set_property('enable-default-context-menu', False)
        webview.set_settings(ws)
        webview.set_zoom_level(zoom_level)
        webview.set_maintains_back_forward_list(True)
        return webview

    def make_toolbar(self, toolbar_items, theme_items):
        toolbar = gtk.Toolbar()
        toolbar.set_orientation(gtk.ORIENTATION_HORIZONTAL)
        toolbar.set_style(gtk.TOOLBAR_BOTH_HORIZ)

        # Add stock toolbar items
        for toolbar_item in toolbar_items:
            stock_item, label, callback, user_data, pos = toolbar_item
            callback_method = getattr(self, 'ev_tb_' + callback)
            button = gtk.ToolButton(stock_item)
            button.set_label(label)
            button.connect('clicked', callback_method)
            button.set_is_important(True)
            toolbar.insert(button, pos)

        # Add a theme / template selection dropdown to the toolbar
        menu = gtk.Menu()
        for theme_item in theme_items:
            menu_item = gtk.MenuItem(theme_item[0])
            menu_item.connect('activate', self.ev_tb_theme, theme_item[1])
            menu.append(menu_item)
            menu_item.show()
        toolbar_theme_menu = gtk.MenuToolButton(None, "Theme")
        toolbar_theme_menu.set_is_important(True)
        toolbar_theme_menu.set_tooltip_text('Themes')
        toolbar_theme_menu.set_menu(menu)
        toolbar.insert(toolbar_theme_menu, 4)

        return toolbar

    def run(self):
        """
        Start the GUI
        """
        gtk.main()

    def load_markdown(self):
        """
        Load markdown into the webview. Saves the scrolling position and
        restores it after loading.
        """
        # Save some scrolling state information so we can reset it after
        # reload.
        vadj = self.scroll_window.get_vadjustment()
        self.scroll_pos = vadj.value
        self.at_bottom = vadj.value == (vadj.upper - vadj.page_size)

        md_html = self.mdrenderer.render()
        md_path = self.mdrenderer.get_md_path()
        self.webview.load_string(md_html, "text/html", "utf-8", 'file://' + md_path)

    def auto_reload_timer(self):
        """
        Periodically check for inotify events.
        """
        self.mdrenderer.watch_update()
        return True

    def do_stop(self):
        """
        Save the configuration and stop the GUI
        """
        gtk.main_quit()

    def do_back(self):
        """
        Go back in the browser history.
        """
        if self.webview.can_go_back():
            self.webview.go_back()
        else:
            # Since we loud the Markdown preview using load_html_string(),
            # there is no page to go back to, se we reload instead.
            self.do_reload()

    def do_reload(self):
        """
        Reload the markdown
        """
        self.did_reload = True
        self.load_markdown()

    def do_save_html(self):
        """
        Save rendered markdown to a file.
        """
        file_chooser = gtk.FileChooserDialog(
            action=gtk.FILE_CHOOSER_ACTION_SAVE,
            buttons=(
                gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_SAVE, gtk.RESPONSE_OK
            ))
        response = file_chooser.run()
        if response == gtk.RESPONSE_OK:
            md_html = self.mdrenderer.render()
            open(file_chooser.get_filename(), 'w').write(md_html)
        file_chooser.destroy()

    def ev_tb_back(self, button):
        self.do_back()

    def ev_tb_reload(self, button):
        self.do_reload()

    def ev_tb_save_html(self, button):
        self.do_save_html()

    def ev_tb_stop(self, button):
        self.do_stop()

    def ev_tb_theme(self, button, theme):
        self.mdrenderer.set_theme(theme)
        self.do_reload()

    def ev_key_press(self, widget, ev):
        """
        Handle keypress events.
        """
        if ev.keyval in (gtk.keysyms.Escape, gtk.keysyms.q):
            self.do_stop()
        elif ev.keyval in (gtk.keysyms.plus, gtk.keysyms.equal):
            self.webview.set_zoom_level(self.webview.get_zoom_level() + 0.2)
        elif ev.keyval == gtk.keysyms.minus:
            self.webview.set_zoom_level(self.webview.get_zoom_level() - 0.2)
        elif ev.keyval == gtk.keysyms.r:
            self.do_reload()
        elif ev.keyval == gtk.keysyms.j:
            # Scroll down
            vadj = self.scroll_window.get_vadjustment()
            if vadj.value < (vadj.upper - vadj.page_size):
                vadj.set_value(vadj.get_value() + 16)
        elif ev.keyval == gtk.keysyms.k:
            # Scroll up
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.get_value() - 16)
        elif ev.keyval == gtk.keysyms.G:
            # Scroll to bottom
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(vadj.upper - vadj.page_size)
        elif ev.keyval == gtk.keysyms.g:
            # Scroll to top
            vadj = self.scroll_window.get_vadjustment()
            vadj.set_value(0)
        elif ev.keyval == gtk.keysyms.s:
            # Save document
            self.do_save()

    def ev_configure_event(self, window, ev_reposition):
        """
        Save window position and size on resize and move. We can then save it
        later when the application quits, even after the 'destroy' event has
        been triggered.
        """
        win_size = self.win_main.get_size()
        win_pos = self.win_main.get_position()
        zoom_level = self.webview.get_zoom_level()
        self.width = win_size[0]
        self.height = win_size[1]
        self.pos_x = win_pos[0]
        self.pos_y = win_pos[1]
        self.zoom_level = zoom_level

    def ev_load_status(self, webview, load_status):
        """
        Handle events regarding load status:

        - Set back the scroll position after a reload.
        """
        if (
            self.did_reload and
            self.webview.get_load_status() == webkit.LOAD_FINISHED
           ):
            while gtk.events_pending():
                gtk.main_iteration_do()
            vadj = self.scroll_window.get_vadjustment()
            if not self.at_bottom:
                # Scroll back to previous position
                vadj.set_value(self.scroll_pos)
            else:
                # Previously at bottom, so scroll to bottom, to show any new
                # content
                vadj.set_value(vadj.upper - vadj.page_size)
            self.did_reload = False

    def ev_destroy(self, widget):
        """
        Window was destroyed. Call stop routine to save state and such.
        """
        self.do_stop()


if __name__ == "__main__":
    parser = optparse.OptionParser(version="%prog v%%MASTER%%")
    parser.set_usage(sys.argv[0] + " <file.md>")

    parser.add_option("-k", "--keep-on-top", dest="keep_on_top", action="store_true", default=False, help="Keep window on top")
    parser.add_option("-t", "--theme", dest="theme", action="store", default=None, help="Theme (name or full path to .html). Default: github")

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.print_usage()
        sys.exit(1)

    try:
        with open(args[0], 'r') as test_open:
            pass
    except IOError as err:
        sys.stderr.write("{}\n".format(err))
        sys.exit(1)

    config = Config(os.path.expanduser('~/.config/mdpreview.conf'))
    if options.theme is not None:
        config.set('theme', options.theme)

    theme_dir = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'themes')
    mdrenderer = MDRenderer(args[0], theme_dir=theme_dir, theme=config.get('theme'))
    gui = GUI(mdrenderer,
              width=config.get('width'),
              height=config.get('height'),
              pos_x=config.get('pos_x'),
              pos_y=config.get('pos_y'),
              zoom_level=config.get('zoom_level'),
              keep_on_top=options.keep_on_top)

    gui.run()
    config.set('height', gui.height)
    config.set('width', gui.width)
    config.set('pos_x', gui.pos_x)
    config.set('pos_y', gui.pos_y)
    config.set('zoom_level', gui.zoom_level)
    config.set('theme', mdrenderer.theme)
    config.save()
